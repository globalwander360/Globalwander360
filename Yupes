@ExtendWith(MockitoExtension.class)
public class TransactionPropertyServiceImplTest {

    @InjectMocks
    private TransactionPropertyServiceImpl transactionPropertyServiceImpl;

    @Mock
    private SomeDependencyService mockDependencyService; // Replace with actual class used for getPropertyNamesByEventIdAndType

    @Test
    public void testGetPropertyNames_AllValidProperties() {
        String eventId = "evt123";
        Map<String, String> propertyIdNameMap = new HashMap<>();
        propertyIdNameMap.put("1", "C1");
        propertyIdNameMap.put("2", "C2");

        List<Long> mockPropertyIds = Arrays.asList(1L, 2L);

        Mockito.when(mockDependencyService.getPropertyNamesByEventIdAndType(eventId, "COMPLETION_MOTIVE"))
               .thenReturn(mockPropertyIds);

        // Inject behavior if needed or make method public for test
        String result = transactionPropertyServiceImpl.getPropertyNames(eventId, propertyIdNameMap);

        Assertions.assertEquals("C1,C2", result);
    }

    @Test
    public void testGetPropertyNames_PartiallyValidProperties() {
        String eventId = "evt456";
        Map<String, String> propertyIdNameMap = new HashMap<>();
        propertyIdNameMap.put("1", "C1");
        propertyIdNameMap.put("3", null);  // null should be ignored

        List<Long> mockPropertyIds = Arrays.asList(1L, 3L);

        Mockito.when(mockDependencyService.getPropertyNamesByEventIdAndType(eventId, "COMPLETION_MOTIVE"))
               .thenReturn(mockPropertyIds);

        String result = transactionPropertyServiceImpl.getPropertyNames(eventId, propertyIdNameMap);

        Assertions.assertEquals("C1", result);  // Only one valid name
    }

    @Test
    public void testGetPropertyNames_EmptyAfterFiltering() {
        String eventId = "evtEmpty";
        Map<String, String> propertyIdNameMap = new HashMap<>();  // no valid mapping

        List<Long> mockPropertyIds = Arrays.asList(10L, 20L);

        Mockito.when(mockDependencyService.getPropertyNamesByEventIdAndType(eventId, "COMPLETION_MOTIVE"))
               .thenReturn(mockPropertyIds);

        String result = transactionPropertyServiceImpl.getPropertyNames(eventId, propertyIdNameMap);

        Assertions.assertNull(result);
    }

    @Test
    public void testGetPropertyNames_ExceptionThrown() {
        String eventId = "evtError";
        Map<String, String> propertyIdNameMap = new HashMap<>();

        Mockito.when(mockDependencyService.getPropertyNamesByEventIdAndType(eventId, "COMPLETION_MOTIVE"))
               .thenThrow(new RuntimeException("Service error"));

        String result = transactionPropertyServiceImpl.getPropertyNames(eventId, propertyIdNameMap);

        Assertions.assertNull(result);
    }

    @Test
    public void testGetPropertyNames_EmptyPropertyIdsList() {
        String eventId = "evtEmptyList";
        Map<String, String> propertyIdNameMap = new HashMap<>();

        Mockito.when(mockDependencyService.getPropertyNamesByEventIdAndType(eventId, "COMPLETION_MOTIVE"))
               .thenReturn(Collections.emptyList());

        String result = transactionPropertyServiceImpl.getPropertyNames(eventId, propertyIdNameMap);

        Assertions.assertNull(result);
    }
}
